SQL
--------------------------------------------------------------------------------------------------------------------------------
> COUNT - it counts no of rows in table.
	> 3 flavours
		1. COUNT(*) - count all rows with null and duplicate rows.
		2. COUNT(DISTINCT <column-name>) - returns the number of unique and non-null items in a group.
		3. COUNT(ALL <column-name>) - returns the number of non-null items in a group, including duplicate values.
		
> LENGTH - eturns a positive integer that represents the number of characters in the string_expression.
	> 2 flavours
		1. If the string_expression is NULL, the LENGTH() function returns NULL.
		*2. If the string_expression is CHAR data type, its length will include all leading and trailing blanks.

> ORDER BY - sorts data in ascending/ descending order
	> specify DESC for descending, ASC for ascending
	> SPECIFY MULTIPLE COLUMNS
		> SELECT CITY, LENGTH(CITY) AS LEN FROM STATION ORDER BY LEN, CITY
		> We can specify different ordering of multiple columns
			> SELECT CITY, LENGTH(CITY) AS LEN FROM STATION ORDER BY LEN DESC, CITY ASC
	> We can specify column index(starting with 0) if not using selectlist names
	> We can also mention null position by
		> NULLS LAST, NULLS FIRST
		> Default -
			> DESC - NULLS FIRST
			> ASC - NULLS LAST
		> Ex - SELECT COLUMN_NAME FROM TABLE ORDER BY COLUMN_NAME DESC NULLS LAST;
	
NOTE - we cannot use order by in union in both queries,
		ex - SELECT MIN(CITY), LENGTH(CITY) AS LEN FROM STATION GROUPY BY LENGTH(CITY) ORDER BY LEN FETCH FIRST ROW ONLY
				UNION
			SELECT MAX(CITY), LENGTH(CITY) AS LEN FROM STATION GROUPY BY LENGTH(CITY) ORDER BY LEN DESC FETCH FIRST ROW ONLY;
		this will give error, cause order by is used on overall dataset, cannot use in both query

> SUBSTR - function extracts a substring from a string with various flexible options.
		> SYNTAX - 
				SUBSTR( str, start_position [, substring_length, [, occurrence ]] );
				
			Arguments - 	
			> str - str is the string that you want to extract the substring. The data type of str can be CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.
			> start_position - 
				start_position is an integer that determines where the substring starts. The following explains the effect of the start_position value:

					> Indexing starts from 1, but if we specify zero then treats as 1.
					> In case the start_position is positive, the SUBSTR() function will count from the beginning of the str to determine the first character of the substring.
					> If the start_position is negative, then the SUBSTR() function will count backward from the end of the str to find the first character of the substring.
			> substring_length - 
				> substring_length determines the number of characters in the substring. If substring_length is omitted, the SUBSTR() function returns all characters starting from the start_position.

				> In case the substring_length is less than 1, the SUBSTR() function returns null.
		
> REGEXP_LIKE() - function is an advanced version of the LIKE operator. The REGEXP_LIKE() function returns rows that match a regular expression pattern.
		> SYNTAX - 
				REGEXP_LIKE(source_string, search_pattern [, match_parameter]);
			
			Arguments - 
			> source_string - is a string for which to be searched. Typically, it is a character column of any data type CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.
			> search_pattern - is a literal string that represents the regular expression pattern to be matched.
			> match_parameter - is a literal string that changes the default matching behavior of the REGEXP_LIKE() function.

		> Sample Case -
			> column consisting a - REGEXP_LIKE(column_name, 'a')
			> column starting with a - REGEXP_LIKE(column_name, '^a')
			> column ending with a - REGEXP_LIKE(column_name, 'a$')
			> column starting either with a,b - REGEXP_LIKE(column_name, '^a|^b')
			> column consisting a exactly n times - REGEXP_LIKE(column_name, 'a{2}')
			
> CASE CONDITION
	> Syntax
		CASE [ expression ]

		   WHEN condition_1 THEN result_1
		   WHEN condition_2 THEN result_2
		   ...
		   WHEN condition_n THEN result_n

		   ELSE result

		END
	> ALl expression and conditions must be of same datatype
	> ALL result must be of same datatype
	> If none condition satisfy it returns result of ELSE, if ELSE is not specified then oracle return null
	> We cannot explicitly use NULL in condition or result	
			
> Order of Execution Of a Query
    > FROM/ JOIN
    > WHERE
    > GROUP BY
    > HAVING
    > SELECT
    > DISTINCT
    > ANALYTIC FUNTION - RANK(), DENSE_RANK()..
    > ORDER BY
    > LIMIT/ OFFSET

> LISTAGG
	> aggregates values within same group
	> with group by
		> select deptno, LISTAGG(ename, ',') WITHIN GROUP (ORDER BY ename) as employees
			FROM emp GROUP BY deptno ORDER BY deptno;
	> with analytic function
		> SELECT deptno, hire_date, last_name,
			LISTAGG(last_name, ',') WITHIN GROUP (ORDER BY hire_date, last_name) OVER (PARTITION BY deptno) as employees
			FROM emp WHERE hire_date < '01-SEP-2003' ORDER BY deptno, hire_date, last_name;

> RANK()
    > It is an analytic function that calculates the rank of a value in a set of values.
    > Follows Olympic rules, if two people share a gold then no silver medalist
        > ie if tie happens between 2 people with rank 1 so them next rank will be given is 3
    > Rank is not in sequence.
    > Syntax -
        RANK()
        	OVER ([ query_partition_clause ] order_by_clause)

        > The order_by_clause is required. It specifies the order of rows in each partition or in the whole result set.
            The order_by_clause has the following form:
                ORDER BY expression1 [,expression2,...] [ASC | DESC ] [NULLS FIRST | LAST]

        > The query_partition_clause is optional. It distributes the rows into partitions to which the function is applied.
            If you omit the query_partition_clause, the function will treat the whole result set as a single partition.
            The query_partition_clause has the following form:
                PARTITION BY expression1 [,expression2, ...]

    > If we use query_partition_clause, then rank is given to set of values under same group,
        next group rank starts with 1 again

> DENSE_RANK()
    > Similar to RANK(), but here we will have sequence of rank instead of skipping next rank in case of tie
    > Syntax -
            DENSE_RANK()
            	OVER ([ query_partition_clause ] order_by_clause)

        > The order_by_clause is required. It specifies the order of rows in each partition or in the whole result set.
            The order_by_clause has the following form:
                ORDER BY expression1 [,expression2,...] [ASC | DESC ] [NULLS FIRST | LAST]

        > The query_partition_clause is optional. It distributes the rows into partitions to which the function is applied.
            If you omit the query_partition_clause, the function will treat the whole result set as a single partition.
            The query_partition_clause has the following form:
                PARTITION BY expression1 [,expression2, ...]

    > If we use query_partition_clause, then rank is given to set of values under same group,
            next group rank starts with 1 again

> ROW_NUMBER() - SELECTING N ROWS WITH ORDER BY CLAUSE
	> This is another analytic function for ranking given set of values
	> Here we will have unique values even in case of tie
	> SYNTAX -
				ROW_NUMBER() OVER (
				   [query_partition_clause]
				   order_by_clause
				)
		> The order_by_clause is required. It specifies the order of rows in each partition or in the whole result set.
		    The order_by_clause has the following form:
			 	ORDER BY expression1 [,expression2,...] [ASC | DESC ] [NULLS FIRST | LAST]

		> The query_partition_clause is optional. It distributes the rows into partitions to which the function is applied.
		    If you omit the query_partition_clause, the function will treat the whole result set as a single partition.
		     The query_partition_clause has the following form:
				PARTITION BY expression1 [,expression2, ...]

	> Using ROW_NUMBER() for pagination
		> Suppose you want to display products by pages with the list price from high to low, each page has 10 products.
		    To display the third page, you use the ROW_NUMBER() function as follows:
				WITH cte_products AS (
				    SELECT
				        row_number() OVER(
				            ORDER BY list_price DESC
				        ) row_num,
				        product_name,
				        list_price
				    FROM
				        products
				)
				SELECT * FROM cte_products
				WHERE row_num > 30 and row_num <= 40;

> LAG()
    > To compute value from previous rows
	> Syntax - 
		LAG
		  { ( value_expr [, offset [, default]]) [ { RESPECT | IGNORE } NULLS ] 
		  | ( value_expr [ { RESPECT | IGNORE } NULLS ] [, offset [, default]] )
		  }
		  OVER ([ query_partition_clause ] order_by_clause)
	> Ex - 
		SELECT empno,
		       ename,
		       job,
		       sal,
		       LAG(sal, 1, 0) OVER (ORDER BY sal) AS sal_prev, --LAG(column_name, no_of_column, default_if_not_present)
		       sal - LAG(sal, 1, 0) OVER (ORDER BY sal) AS sal_diff
		FROM   emp;
	
> LEAD()
	> To compute value from next rows
	> Syntax -
		LEAD
		  { ( value_expr [, offset [, default]] ) [ { RESPECT | IGNORE } NULLS ] 
		  | ( value_expr [ { RESPECT | IGNORE } NULLS ] [, offset [, default]] )
		  }
		  OVER ([ query_partition_clause ] order_by_clause)
	> Ex - 
		SELECT empno,
		       ename,
		       job,
		       sal,
		       LEAD(sal, 1, 0) OVER (ORDER BY sal) AS sal_next,--LEAD(column_name, no_of_column, default_if_not_present)
		       LEAD(sal, 1, 0) OVER (ORDER BY sal) - sal AS sal_diff
		FROM   emp;

