SQL
----------------------------------------------------------------------------------------------------------------
> COUNT - it counts no of rows in table.
	> 3 flavours
		1. COUNT(*) - count all rows with null and duplicate rows.
		2. COUNT(DISTINCT <column-name>) - returns the number of unique and non-null items in a group.
		3. COUNT(ALL <column-name>) - returns the number of non-null items in a group, including duplicate values.
		
> LENGTH - eturns a positive integer that represents the number of characters in the string_expression.
	> 2 flavours
		1. If the string_expression is NULL, the LENGTH() function returns NULL.
		*2. If the string_expression is CHAR data type, its length will include all leading and trailing blanks.

> ORDER BY - sorts data in ascending/ descending order
	> specify DESC for descending, ASC for ascending
	> SPECIFY MULTIPLE COLUMNS
		> SELECT CITY, LENGTH(CITY) AS LEN FROM STATION ORDER BY LEN, CITY
		> We can specify different ordering of multiple columns
			> SELECT CITY, LENGTH(CITY) AS LEN FROM STATION ORDER BY LEN DESC, CITY ASC
	> We can specify column index(starting with 0) if not using selectlist names
	> We can also mention null position by
		> NULLS LAST, NULLS FIRST
		> Default -
			> DESC - NULLS FIRST
			> ASC - NULLS LAST
		> Ex - SELECT COLUMN_NAME FROM TABLE ORDER BY COLUMN_NAME DESC NULLS LAST;
			
> ROW_NUMBER() - SELECTING N ROWS WITH ORDER BY CLAUSE
	> We cannot apply ROWNUMBER after ORDER BY CLAUSE
		// this will give error
		> SELECT CITY, LENGTH(CITY) FROM STATION ORDER BY LENGTH(CITY), CITY WHERE ROWNUM=1;
	> Further applying where clause before order by will not fulfill our requirement
	> Thus we use ROW_NUMBER()	
	> SYNTAX - 
				ROW_NUMBER() OVER (
				   [query_partition_clause] 
				   order_by_clause
				)
		> The order_by_clause is required. It specifies the order of rows in each partition or in the whole result set. The 			order_by_clause has the following form:
			 	ORDER BY expression1 [,expression2,...] [ASC | DESC ] [NULLS FIRST | LAST]
		
		> The query_partition_clause is optional. It distributes the rows into partitions to which the function is applied. 			If you omit the query_partition_clause, the function will treat the whole result set as a single partition. The 			query_partition_clause has the following form:
				PARTITION BY expression1 [,expression2, ...]
	
	> Using ROW_NUMBER() for pagination
		> Suppose you want to display products by pages with the list price from high to low, each page has 10 products. To 			display the third page, you use the ROW_NUMBER() function as follows:
				WITH cte_products AS (
				    SELECT 
				        row_number() OVER(
				            ORDER BY list_price DESC
				        ) row_num, 
				        product_name, 
				        list_price
				    FROM 
				        products
				)
				SELECT * FROM cte_products
				WHERE row_num > 30 and row_num <= 40;
	
NOTE - we cannot use order by in union in both queries,
		ex - SELECT MIN(CITY), LENGTH(CITY) AS LEN FROM STATION GROUPY BY LENGTH(CITY) ORDER BY LEN FETCH FIRST ROW ONLY
				UNION
			SELECT MAX(CITY), LENGTH(CITY) AS LEN FROM STATION GROUPY BY LENGTH(CITY) ORDER BY LEN DESC FETCH FIRST ROW 			ONLY;
		this will give error, cause order by is used on overall dataset, cannot use in both query

> SUBSTR - function extracts a substring from a string with various flexible options.
		> SYNTAX - 
				SUBSTR( str, start_position [, substring_length, [, occurrence ]] );
				
			Arguments - 	
			> str - str is the string that you want to extract the substring. The data type of str can be CHAR, VARCHAR2, 				NCHAR, NVARCHAR2, CLOB, or NCLOB.
			> start_position - 
				start_position is an integer that determines where the substring starts. The following explains the effect 				of the start_position value:

					> Indexing starts from 1, but if we specify zero then treats as 1.
					> In case the start_position is positive, the SUBSTR() function will count from the beginning of the str 						to determine the first character of the substring.
					> If the start_position is negative, then the SUBSTR() function will count backward from the end of the 						str to find the first character of the substring.
			> substring_length - 
				> substring_length determines the number of characters in the substring. If substring_length is omitted, the 					SUBSTR() function returns all characters starting from the start_position.

				> In case the substring_length is less than 1, the SUBSTR() function returns null.
		
> REGEXP_LIKE() - function is an advanced version of the LIKE operator. The REGEXP_LIKE() function returns rows that match a regular expression pattern.
		> SYNTAX - 
				REGEXP_LIKE(source_string, search_pattern [, match_parameter]);
			
			Arguments - 
			> source_string - is a string for which to be searched. Typically, it is a character column of any data type 				CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, or NCLOB.
			> search_pattern - is a literal string that represents the regular expression pattern to be matched.
			> match_parameter - is a literal string that changes the default matching behavior of the REGEXP_LIKE() function.

		> Sample Case -
			> column consisting a - REGEXP_LIKE(column_name, 'a')
			> column starting with a - REGEXP_LIKE(column_name, '^a')
			> column ending with a - REGEXP_LIKE(column_name, 'a$')
			> column starting either with a,b - REGEXP_LIKE(column_name, '^a|^b')
			> column consisting a exactly n times - REGEXP_LIKE(column_name, 'a{2}')
			
> CASE CONDITION
	> Syntax
		CASE [ expression ]

		   WHEN condition_1 THEN result_1
		   WHEN condition_2 THEN result_2
		   ...
		   WHEN condition_n THEN result_n

		   ELSE result

		END
	> ALl expression and conditions must be of same datatype
	> ALL result must be of same datatype
	> If none condition satisfy it returns result of ELSE, if ELSE is not specified then oracle return null
	> We cannot explicitly use NULL in condition or result	
			
		